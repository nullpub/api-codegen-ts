import { ReferenceObject } from '../../types/openapi-3.0.2';

/**
 * This file contains utilies for dealing with ReferenceObjects and
 * parsing local JSON pointers to unique names that are used for
 * types and interfaces
 */

export function isRef(obj: unknown): obj is ReferenceObject {
  if (typeof obj === 'object' && obj !== null) {
    return (
      obj.hasOwnProperty('$ref') &&
      typeof (<{ $ref: unknown }>obj).$ref === 'string'
    );
  }
  return false;
}

const toRefPath = (str: string): string[] => {
  const refArray = str.split('/');
  const refPath = refArray[refArray.length - 1].split('.');
  return refPath;
};

/**
 * Swagger/Openapi specs generated by C#'s swashbuckler tend to keep
 * the dotted namespace path of the language as the pointer key.
 * Typescript does not allow . as a valid model key so must be removed.
 * The namespace paths are also quite long. In order to truncate
 * the model names this function takes a full ref string of the general
 * format:
 *
 * #/components/schemas/Some.Very.Long.Namespace.Path
 *
 * and starts by returning Path for depth 1, then NamespacePath for depth 2,
 * and so on until the full string is being returned (without .s).
 */
export function refName(str: string, depth: number = 1): string {
  const refPath = toRefPath(str);
  const refName = refPath
    .splice(refPath.length - depth) // Take last `depth` words
    .join('')
    .replace(/[^A-Za-z!?]/g, '');
  return refName;
}

/**
 * This function generates a truncated model name function. The closure
 * keeps a cache and reverse cache from/to the original reference in order
 * to reduce naming conflicts.
 */
const parseRefFactory = () => {
  const cache: Record<string, string> = {};
  const revCache: Record<string, string> = {};

  const parseRef = ($ref: string) => {
    if (cache[$ref]) {
      return cache[$ref];
    }

    const refPath = toRefPath($ref);
    const maxDepth = refPath.length;

    let name = refName($ref) || $ref;
    let depth = 1;

    while (depth <= maxDepth && revCache[name]) {
      depth++;
      name = refName($ref, depth);
    }

    cache[$ref] = name;
    revCache[name] = $ref;

    return name;
  };
  return parseRef;
};

export const parseRef = parseRefFactory();
